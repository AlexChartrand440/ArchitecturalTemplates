import org.scaledl.architecturaltemplates.repositories.cloudscale.black.ProfilesLibrary;
import org.scaledl.architecturaltemplates.repositories.cloudscale.black.ThreeLayerLibrary;
import org.scaledl.architecturaltemplates.repositories.cloudscale.black.LoadbalancingLibrary;

modeltype PCM_ALLOC uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Allocation/5.0';
modeltype PCM_REP uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Repository/5.0';
modeltype PCM_SYS uses 'http://sdq.ipd.uka.de/PalladioComponentModel/System/5.0';
modeltype PCM_USE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/UsageModel/5.0';
modeltype PCM_RES_ENV uses 'http://sdq.ipd.uka.de/PalladioComponentModel/ResourceEnvironment/5.0';
modeltype PCM_CORE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/5.0';
modeltype EMF_PROFILE_APPLICATION uses 'http://www.modelversioning.org/emfprofile/application/1.1';
modeltype EMF_PROFILE uses 'http://www.modelversioning.org/emfprofile/1.1';
modeltype PCM_RES_TYPE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/ResourceType/5.0';
modeltype PCMCore uses pcm::core('http://sdq.ipd.uka.de/PalladioComponentModel/5.0');
modeltype PCMEntity uses pcm::core::entity('http://sdq.ipd.uka.de/PalladioComponentModel/5.0');
modeltype PCMComposition uses pcm::core::composition('http://sdq.ipd.uka.de/PalladioComponentModel/5.0');
modeltype PCM_MEASURINGPOINT uses 'http://palladiosimulator.org/PCM/MeasuringPoint/1.0';
modeltype PCM_PMS uses 'http://simulizar.palladiosimulator.org/PalladioMonitoringSpecification/1.0';
modeltype PCM_EDP2MEASURINGPOINT uses 'http://palladiosimulator.org/EDP2/MeasuringPoint/0.9.1';
modeltype PCM_EDP2DATA uses 'http://palladiosimulator.org/EDP2/ExperimentData/0.9.1';
modeltype PCM_SLO uses 'http://palladiosimulator.org/ServiceLevelObjective/1.0';
	

/**
 * Transforms a system where assembly context are annotated with the "Replicable Assembly
 * Context" AT roles to a PCM instance where each such assembly context can dynamically
 * horizontal scale. Each replicated assembly context is allocated to a crorrespond
 * replicated resource container. This resource container has the same specification as
 * the original container.
 *
 * Replication is based on upper and lower thresholds for scaling out and in, respectively.
 * Such thresholds stick to average response times taken at the component in intervals.
 * Intervals and thresholds can externally be set via properties.
 *
 * TODO How can properties be externally set?
 * FIXME Copied from the original ThreeLayer completion; did not start further implementation yet :(
 *
 * @see http://cloudscale.xlab.si/wiki/index.php/Dynamic_Horizontal_Scaling_CAT
 *
 * @author Sebastian Lehrig
 * @author Daria Giacinto
 **/
transformation DynamicHorizontalScalingAssemblyContext( inout pcmSystem : PCM_SYS,
						   inout pcmResourceEnvironment : PCM_RES_ENV,
						   inout pcmUsage: PCM_USE,
						   out pcmUsageScenarioMeasuringPoint : PCM_MEASURINGPOINT,
						   out slo : PCM_SLO,
						    out pms : PCM_PMS
						   );
						   

property threshold : Real;
property interval : Real = 10;

main() {	
	log ('Architectural Template Transformation "Dynamic Horizontal Scaling Assembly Context" started');
	
	// Get relevant PCM model elements
	var system : System := pcmSystem.rootObjects()![System];
	assert fatal(hasAppliedStereotype(system, "DynamicHorizontalScalingAssemblyContextSystem"))
		with log ("The system is not a dynamical horizontal scaling assembly context system!");
	var assemblyContexts : Set(AssemblyContext) := system.assemblyContexts__ComposedStructure;	
	var usageModel : UsageModel := pcmUsage.rootObjects()![UsageModel];
	var usageScenario : UsageScenario := usageModel.usageScenario_UsageModel![UsageScenario];
	var resourceEnvironment : ResourceEnvironment := pcmResourceEnvironment.rootObjects()![ResourceEnvironment];
	var resourceContainers : Set(ResourceContainer) := resourceEnvironment.resourceContainer_ResourceEnvironment;	
	assemblyContexts -> forEach(assemblyContext){
		if(hasAppliedStereotype(assemblyContext,"ReplicableAssemblyContext")){
			var numberOfReplicas : Integer := getNumberOfReplicas(assemblyContext,"numberOfReplicas","ReplicableAssemblyContext");
			applyStereotype(assemblyContext, "LoadbalancedAssemblyContext");
			setIntTaggedValue(assemblyContext, numberOfReplicas, "LoadbalancedAssemblyContext", "numberOfReplicas");
			
		};
	};
	
	var usageScenarioMeasuringPoint : UsageScenarioMeasuringPoint := usageScenario.map createUsageScenarioMeasuringPoint();
	var sloRepo : ServiceLevelObjectiveRepository := usageScenarioMeasuringPoint.map createServiceLevelObjectiveRepository();
	var pmsModel: PMSModel := usageScenarioMeasuringPoint.map addPerformanceMeasurementsToPmsModel();
	log ('Architectural Template Transformation "Dynamic Horizontal Scaling Assembly Context" finished');
}

mapping MeasuringPoint::addPerformanceMeasurementsToPmsModel():PMSModel@pms{
	performanceMeasurements += new PerformanceMeasurement(self);
}
mapping MeasuringPoint:: createServiceLevelObjectiveRepository(): ServiceLevelObjectiveRepository@slo{
	servicelevelobjectives += new ServiceLevelObjective(self);
}

constructor ServiceLevelObjective::ServiceLevelObjective(mp:MeasuringPoint){
	measuringPoint := mp;
}

constructor PerformanceMeasurement :: PerformanceMeasurement(mp : MeasuringPoint){
	measuringPoint := mp;
	measurementSpecification := new MeasurementSpecification();
}

constructor MeasurementSpecification :: MeasurementSpecification(){
	performanceMetric := PerformanceMetricEnum::ResponseTime;
	statisticalCharacterization := StatisticalCharacterizationEnum::ArithmeticMean;
	temporalRestriction := new Intervall(interval);
}
constructor Intervall::Intervall(interval:Real){
	intervall := interval;
}

mapping UsageScenario::createUsageScenarioMeasuringPoint() : UsageScenarioMeasuringPoint@pcmUsageScenarioMeasuringPoint{
	usageScenario := self;
}


//blackbox helper hasAppliedStereotype(system:Entity, stereotype : String):Boolean;
//blackbox helper applyStereotype(pcmEntity:Entity, stereotype:String):Void;
//blackbox helper getResponseTimeThreshold(assemblyContext:AssemblyContext, taggedValueName:String, stereotypeName: String):Real;
//blackbox helper getResponseTimeInterval(assemblyContext:AssemblyContext, taggedValueName:String, stereotypeName: String):Real;
